name: Release

on:
  push:
    tags: ['v*']

permissions:
  contents: write
  packages: write

env:
  REGISTRY: ghcr.io
  IMAGE_NAME_SERVER: ${{ github.repository }}-server

jobs:
  # ============================================
  # VALIDATE VERSION CONSISTENCY
  # ============================================
  validate-version:
    runs-on: ubuntu-latest
    outputs:
      version: ${{ steps.version.outputs.version }}
      is_prerelease: ${{ steps.version.outputs.is_prerelease }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate and extract version
        id: version
        run: |
          TAG_VERSION="${{ github.ref_name }}"
          VERSION="${TAG_VERSION#v}"  # Remove 'v' prefix
          
          echo "Tag version: $TAG_VERSION"
          echo "Clean version: $VERSION"
          
          # Check if pre-release
          if [[ "$TAG_VERSION" =~ (alpha|beta|rc|dev|preview) ]]; then
            echo "is_prerelease=true" >> $GITHUB_OUTPUT
            echo "Detected pre-release version"
          else
            echo "is_prerelease=false" >> $GITHUB_OUTPUT
            echo "Detected stable version"
          fi
          
          # Validate package.json version
          PACKAGE_VERSION=$(jq -r .version desktop/package.json)
          echo "package.json version: $PACKAGE_VERSION"
          
          if [ "$PACKAGE_VERSION" != "$VERSION" ]; then
            echo "::error::Version mismatch! Tag: $VERSION, package.json: $PACKAGE_VERSION"
            echo "Please update desktop/package.json to match the release tag."
            exit 1
          fi
          
          # Validate tauri.conf.json version
          TAURI_VERSION=$(jq -r .version desktop/src-tauri/tauri.conf.json)
          echo "tauri.conf.json version: $TAURI_VERSION"
          
          if [ "$TAURI_VERSION" != "$VERSION" ]; then
            echo "::error::Version mismatch! Tag: $VERSION, tauri.conf.json: $TAURI_VERSION"
            echo "Please update desktop/src-tauri/tauri.conf.json to match the release tag."
            exit 1
          fi
          
          # Validate Cargo.toml version
          CARGO_VERSION=$(grep '^version = ' desktop/src-tauri/Cargo.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
          echo "Cargo.toml version: $CARGO_VERSION"
          
          if [ "$CARGO_VERSION" != "$VERSION" ]; then
            echo "::error::Version mismatch! Tag: $VERSION, Cargo.toml: $CARGO_VERSION"
            echo "Please update desktop/src-tauri/Cargo.toml to match the release tag."
            exit 1
          fi
          
          echo "‚úÖ All versions are consistent: $VERSION"
          echo "version=$VERSION" >> $GITHUB_OUTPUT

  # ============================================
  # BUILD DESKTOP APP (Tauri)
  # ============================================
  build-desktop:
    needs: [validate-version]
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-latest'
            args: '--target aarch64-apple-darwin'
            arch: 'aarch64'
          - platform: 'macos-latest'
            args: '--target x86_64-apple-darwin'
            arch: 'x86_64'
          - platform: 'ubuntu-22.04'
            args: ''
            arch: 'amd64'
          - platform: 'windows-latest'
            args: ''
            arch: 'x64'

    runs-on: ${{ matrix.platform }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.platform == 'macos-latest' && 'aarch64-apple-darwin,x86_64-apple-darwin' || '' }}

      - name: Install Linux dependencies
        if: matrix.platform == 'ubuntu-22.04'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf protobuf-compiler

      - name: Install protoc (macOS)
        if: matrix.platform == 'macos-latest'
        run: brew install protobuf

      - name: Install protoc (Windows)
        if: matrix.platform == 'windows-latest'
        run: choco install protoc

      - name: Install frontend dependencies
        working-directory: desktop
        run: npm ci

      - name: Build Tauri App
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          projectPath: desktop
          args: ${{ matrix.args }}

      - name: Upload Desktop Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: desktop-${{ matrix.platform }}-${{ matrix.arch }}
          path: |
            desktop/src-tauri/target/release/bundle/**/*.dmg
            desktop/src-tauri/target/release/bundle/**/*.app
            desktop/src-tauri/target/release/bundle/**/*.deb
            desktop/src-tauri/target/release/bundle/**/*.AppImage
            desktop/src-tauri/target/release/bundle/**/*.exe
            desktop/src-tauri/target/release/bundle/**/*.msi
            desktop/src-tauri/target/**/release/bundle/**/*.dmg
            desktop/src-tauri/target/**/release/bundle/**/*.deb
            desktop/src-tauri/target/**/release/bundle/**/*.AppImage
            desktop/src-tauri/target/**/release/bundle/**/*.exe
            desktop/src-tauri/target/**/release/bundle/**/*.msi

  # ============================================
  # BUILD CLI (Terminal TUI + Daemon)
  # ============================================
  build-cli:
    needs: [validate-version]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: cli/go.mod

      - name: Build CLI Binaries
        run: |
          mkdir -p dist
          VERSION=${{ github.ref_name }}
          COMMIT=${{ github.sha }}
          DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          LDFLAGS="-s -w -X main.version=${VERSION} -X main.commit=${COMMIT} -X main.date=${DATE} -X main.builtBy=github-actions"
          
          # Linux
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="${LDFLAGS}" -o dist/goconnect_${VERSION}_linux_amd64 ./cmd/goconnect
          CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -ldflags="${LDFLAGS}" -o dist/goconnect_${VERSION}_linux_arm64 ./cmd/goconnect
          
          # macOS
          CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags="${LDFLAGS}" -o dist/goconnect_${VERSION}_darwin_amd64 ./cmd/goconnect
          CGO_ENABLED=0 GOOS=darwin GOARCH=arm64 go build -ldflags="${LDFLAGS}" -o dist/goconnect_${VERSION}_darwin_arm64 ./cmd/goconnect
          
          # Windows
          CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags="${LDFLAGS}" -o dist/goconnect_${VERSION}_windows_amd64.exe ./cmd/goconnect
          
          # Verify binaries were created
          echo "Verifying CLI binaries..."
          for binary in dist/goconnect_*; do
            if [ -f "$binary" ]; then
              echo "‚úÖ Created: $binary ($(stat -c%s "$binary") bytes)"
            fi
          done
          
          # Create archives
          cd dist
          for f in goconnect_*_linux_* goconnect_*_darwin_*; do
            if [ -f "$f" ] && [[ ! "$f" =~ \.tar\.gz$ ]]; then
              tar -czvf "${f}.tar.gz" "$f" && rm "$f"
              echo "‚úÖ Archived: ${f}.tar.gz"
            fi
          done
          for f in goconnect_*_windows_*.exe; do
            if [ -f "$f" ]; then
              zip "${f%.exe}.zip" "$f" && rm "$f"
              echo "‚úÖ Archived: ${f%.exe}.zip"
            fi
          done
          
          # Final verification
          echo ""
          echo "Final CLI artifacts:"
          ls -la
          ARTIFACT_COUNT=$(ls -1 | wc -l)
          if [ "$ARTIFACT_COUNT" -lt 5 ]; then
            echo "::error::Expected at least 5 CLI artifacts, found $ARTIFACT_COUNT"
            exit 1
          fi
        working-directory: cli

      - name: Upload CLI Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: cli-binaries
          path: cli/dist/

  # ============================================
  # BUILD SERVER (Self-hosted backend)
  # ============================================
  build-server:
    needs: [validate-version]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: core/go.mod

      - name: Build Server Binaries
        run: |
          mkdir -p dist
          VERSION=${{ github.ref_name }}
          COMMIT=${{ github.sha }}
          DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          LDFLAGS="-s -w -X main.version=${VERSION} -X main.commit=${COMMIT} -X main.date=${DATE} -X main.builtBy=github-actions"
          
          # Linux
          CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="${LDFLAGS}" -o dist/goconnect-server_${VERSION}_linux_amd64 ./cmd/server
          CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -ldflags="${LDFLAGS}" -o dist/goconnect-server_${VERSION}_linux_arm64 ./cmd/server
          
          # macOS  
          CGO_ENABLED=0 GOOS=darwin GOARCH=amd64 go build -ldflags="${LDFLAGS}" -o dist/goconnect-server_${VERSION}_darwin_amd64 ./cmd/server
          CGO_ENABLED=0 GOOS=darwin GOARCH=arm64 go build -ldflags="${LDFLAGS}" -o dist/goconnect-server_${VERSION}_darwin_arm64 ./cmd/server
          
          # Windows
          CGO_ENABLED=0 GOOS=windows GOARCH=amd64 go build -ldflags="${LDFLAGS}" -o dist/goconnect-server_${VERSION}_windows_amd64.exe ./cmd/server
          
          # Verify binaries were created
          echo "Verifying server binaries..."
          for binary in dist/goconnect-server_*; do
            if [ -f "$binary" ]; then
              echo "‚úÖ Created: $binary ($(stat -c%s "$binary") bytes)"
            fi
          done
          
          # Create archives
          cd dist
          for f in goconnect-server_*_linux_* goconnect-server_*_darwin_*; do
            if [ -f "$f" ] && [[ ! "$f" =~ \.tar\.gz$ ]]; then
              tar -czvf "${f}.tar.gz" "$f" && rm "$f"
              echo "‚úÖ Archived: ${f}.tar.gz"
            fi
          done
          for f in goconnect-server_*_windows_*.exe; do
            if [ -f "$f" ]; then
              zip "${f%.exe}.zip" "$f" && rm "$f"
              echo "‚úÖ Archived: ${f%.exe}.zip"
            fi
          done
          
          # Final verification
          echo ""
          echo "Final server artifacts:"
          ls -la
          ARTIFACT_COUNT=$(ls -1 | wc -l)
          if [ "$ARTIFACT_COUNT" -lt 5 ]; then
            echo "::error::Expected at least 5 server artifacts, found $ARTIFACT_COUNT"
            exit 1
          fi
        working-directory: core

      - name: Upload Server Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: server-binaries
          path: core/dist/

  # ============================================
  # BUILD DOCKER IMAGES
  # ============================================
  build-docker:
    runs-on: ubuntu-latest
    needs: [validate-version, build-server]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME_SERVER }}
          tags: |
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}},enable=${{ !startsWith(github.ref_name, 'v0.') }}
            type=raw,value=latest,enable=${{ needs.validate-version.outputs.is_prerelease == 'false' }}

      - name: Build and push Server
        uses: docker/build-push-action@v5
        with:
          context: ./core
          platforms: linux/amd64,linux/arm64
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            VERSION=${{ github.ref_name }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

  # ============================================
  # CREATE GITHUB RELEASE
  # ============================================
  create-release:
    runs-on: ubuntu-latest
    needs: [validate-version, build-desktop, build-cli, build-server, build-docker]
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Prepare release files
        id: prepare
        run: |
          mkdir -p release
          
          echo "üì¶ Collecting artifacts..."
          
          # Copy CLI binaries
          if [ -d "artifacts/cli-binaries" ]; then
            cp artifacts/cli-binaries/* release/
            CLI_COUNT=$(ls artifacts/cli-binaries | wc -l)
            echo "‚úÖ Copied $CLI_COUNT CLI artifacts"
          else
            echo "::error::CLI binaries not found!"
            exit 1
          fi
          
          # Copy Server binaries
          if [ -d "artifacts/server-binaries" ]; then
            cp artifacts/server-binaries/* release/
            SERVER_COUNT=$(ls artifacts/server-binaries | wc -l)
            echo "‚úÖ Copied $SERVER_COUNT server artifacts"
          else
            echo "::error::Server binaries not found!"
            exit 1
          fi
          
          # Copy Desktop artifacts (flatten structure)
          DESKTOP_COUNT=0
          
          # Verify artifacts directory exists
          if [ ! -d "artifacts" ]; then
            echo "::error::Artifacts directory not found!"
            exit 1
          fi
          
          echo "üìÇ Searching for desktop artifacts in: $(pwd)/artifacts"
          echo "üìÅ Artifact directories:"
          ls -la artifacts/
          
          # Function to safely find and copy files by extension
          copy_by_extension() {
            local ext="$1"
            local description="$2"
            
            # Find files and copy them - using simple loop
            for file in $(find artifacts -type f -name "*.$ext" 2>&1 | grep -v "Permission denied"); do
              if [ -f "$file" ]; then
                cp "$file" release/
                DESKTOP_COUNT=$((DESKTOP_COUNT + 1))
                echo "‚úÖ Copied $description: $(basename "$file")"
              fi
            done
          }
          
          # Copy all desktop artifacts by extension
          copy_by_extension "dmg" "macOS DMG"
          copy_by_extension "deb" "Linux DEB"
          copy_by_extension "AppImage" "Linux AppImage"
          copy_by_extension "msi" "Windows MSI"
          
          # EXE installers (Windows) - special pattern matching
          for file in $(find artifacts -type f -name "*-setup.exe" 2>&1 | grep -v "Permission denied"); do
            if [ -f "$file" ]; then
              cp "$file" release/
              DESKTOP_COUNT=$((DESKTOP_COUNT + 1))
              echo "‚úÖ Copied Windows EXE: $(basename "$file")"
            fi
          done
          
          echo ""
          echo "üìä Desktop artifacts copied: $DESKTOP_COUNT"
          
          # Validate we have desktop artifacts - require at least some
          if [ "$DESKTOP_COUNT" -eq 0 ]; then
            echo "::error::No desktop artifacts found! Desktop build may have failed."
            echo "üìã Checking what files exist in artifacts directory:"
            find artifacts -type f | head -30
            exit 1
          fi
          
          # Generate checksums
          cd release
          echo "üîê Generating checksums..."
          sha256sum * > checksums.txt
          echo "‚úÖ Generated checksums.txt"
          
          # List all files
          echo ""
          echo "üìã Release files:"
          ls -la
          
          # Count total
          TOTAL_COUNT=$(ls -1 | wc -l)
          echo ""
          echo "Total release files: $TOTAL_COUNT"
          echo "artifact_count=$TOTAL_COUNT" >> $GITHUB_OUTPUT

      - name: Generate changelog
        id: changelog
        run: |
          # Get previous tag - this may fail for first release, which is expected
          CURRENT_TAG="${{ github.ref_name }}"
          
          # Try to find previous tag, empty string if none exists (first release)
          PREVIOUS_TAG=""
          if git describe --tags --abbrev=0 "${CURRENT_TAG}^" > /dev/null 2>&1; then
            PREVIOUS_TAG=$(git describe --tags --abbrev=0 "${CURRENT_TAG}^")
            echo "Found previous tag: $PREVIOUS_TAG"
          else
            echo "No previous tag found - this appears to be the first release"
          fi
          
          echo "Current tag: $CURRENT_TAG"
          echo "Previous tag: ${PREVIOUS_TAG:-'(none - first release)'}"
          
          if [ -n "$PREVIOUS_TAG" ]; then
            echo "## üìù Changes since $PREVIOUS_TAG" > changelog.md
            echo "" >> changelog.md
            
            # Generate changelog from commits
            git log --pretty=format:"- %s (%h)" "${PREVIOUS_TAG}..${CURRENT_TAG}" | \
              grep -v "^- Merge" | \
              head -50 >> changelog.md
            
            echo "" >> changelog.md
            echo "" >> changelog.md
            echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/${PREVIOUS_TAG}...${CURRENT_TAG}" >> changelog.md
          else
            echo "## üéâ Initial Release" > changelog.md
            echo "" >> changelog.md
            echo "This is the first release of GoConnect!" >> changelog.md
          fi
          
          cat changelog.md
          
          # Set output
          CHANGELOG=$(cat changelog.md)
          echo "changelog<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGELOG" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          name: GoConnect ${{ github.ref_name }}
          draft: false
          prerelease: ${{ needs.validate-version.outputs.is_prerelease == 'true' }}
          make_latest: ${{ needs.validate-version.outputs.is_prerelease == 'false' }}
          generate_release_notes: false
          body: |
            # üöÄ GoConnect ${{ github.ref_name }}
            
            **Virtual LAN made simple** - Connect devices as if they're on the same local network.
            
            ${{ steps.changelog.outputs.changelog }}
            
            ---
            
            ## üì¶ Downloads
            
            ### üñ•Ô∏è Desktop Application (Recommended)
            
            The easiest way to use GoConnect - full GUI with all features.
            
            | Platform | Download |
            |----------|----------|
            | **Windows** | `GoConnect_${{ needs.validate-version.outputs.version }}_x64-setup.exe` or `.msi` |
            | **macOS (Apple Silicon)** | `GoConnect_${{ needs.validate-version.outputs.version }}_aarch64.dmg` |
            | **macOS (Intel)** | `GoConnect_${{ needs.validate-version.outputs.version }}_x64.dmg` |
            | **Linux (Debian/Ubuntu)** | `GoConnect_${{ needs.validate-version.outputs.version }}_amd64.deb` |
            | **Linux (Universal)** | `GoConnect_${{ needs.validate-version.outputs.version }}_amd64.AppImage` |
            
            ### üíª CLI Application
            
            For terminal users and headless servers.
            
            | Platform | Download |
            |----------|----------|
            | Linux (x64) | `goconnect_${{ github.ref_name }}_linux_amd64.tar.gz` |
            | Linux (ARM64) | `goconnect_${{ github.ref_name }}_linux_arm64.tar.gz` |
            | macOS (Apple Silicon) | `goconnect_${{ github.ref_name }}_darwin_arm64.tar.gz` |
            | macOS (Intel) | `goconnect_${{ github.ref_name }}_darwin_amd64.tar.gz` |
            | Windows | `goconnect_${{ github.ref_name }}_windows_amd64.zip` |
            
            ### üñß Server (Self-Hosted)
            
            For running your own GoConnect infrastructure.
            
            | Platform | Download |
            |----------|----------|
            | Linux (x64) | `goconnect-server_${{ github.ref_name }}_linux_amd64.tar.gz` |
            | Linux (ARM64) | `goconnect-server_${{ github.ref_name }}_linux_arm64.tar.gz` |
            | macOS (Apple Silicon) | `goconnect-server_${{ github.ref_name }}_darwin_arm64.tar.gz` |
            | macOS (Intel) | `goconnect-server_${{ github.ref_name }}_darwin_amd64.tar.gz` |
            | Windows | `goconnect-server_${{ github.ref_name }}_windows_amd64.zip` |
            | **Docker** | `ghcr.io/${{ github.repository }}-server:${{ github.ref_name }}` |
            
            ---
            
            ## üöÄ Quick Start
            
            ### Desktop App
            1. Download the installer for your platform
            2. Install and open GoConnect
            3. Create or join a network
            
            ### CLI
            ```bash
            # Download and extract
            tar -xzf goconnect_${{ github.ref_name }}_linux_amd64.tar.gz
            
            # Run setup wizard
            ./goconnect setup
            
            # Or run TUI directly
            ./goconnect
            ```
            
            ### Self-Hosted Server
            ```bash
            # Using Docker (recommended)
            docker run -d -p 8080:8080 ghcr.io/${{ github.repository }}-server:${{ github.ref_name }}
            
            # Or binary
            tar -xzf goconnect-server_${{ github.ref_name }}_linux_amd64.tar.gz
            ./goconnect-server
            ```
            
            ---
            
            ## üîê Verify Downloads
            
            All releases include SHA256 checksums for verification:
            
            ```bash
            sha256sum -c checksums.txt
            ```
            
            ---
            
            üìö [Documentation](https://github.com/${{ github.repository }}#readme) | üêõ [Report Issues](https://github.com/${{ github.repository }}/issues) | üí¨ [Discussions](https://github.com/${{ github.repository }}/discussions)
          files: release/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # ============================================
  # VALIDATE RELEASE
  # ============================================
  validate-release:
    runs-on: ubuntu-latest
    needs: [validate-version, create-release, build-docker]
    steps:
      - name: Validate Docker image
        run: |
          echo "üê≥ Validating Docker image..."
          IMAGE="ghcr.io/${{ github.repository }}-server:${{ github.ref_name }}"
          
          # Pull the image
          docker pull "$IMAGE"
          
          # Verify it runs (just check if it starts)
          docker run --rm "$IMAGE" --help || docker run --rm "$IMAGE" -h || echo "Note: --help may not be implemented"
          
          echo "‚úÖ Docker image validated: $IMAGE"

      - name: Validate GitHub release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "üì¶ Validating GitHub release..."
          
          # Get release info
          RELEASE_INFO=$(gh api repos/${{ github.repository }}/releases/tags/${{ github.ref_name }})
          
          # Check release exists
          RELEASE_ID=$(echo "$RELEASE_INFO" | jq -r '.id')
          if [ -z "$RELEASE_ID" ] || [ "$RELEASE_ID" = "null" ]; then
            echo "::error::Release not found!"
            exit 1
          fi
          echo "‚úÖ Release ID: $RELEASE_ID"
          
          # Check assets
          ASSET_COUNT=$(echo "$RELEASE_INFO" | jq '.assets | length')
          echo "üìé Asset count: $ASSET_COUNT"
          
          if [ "$ASSET_COUNT" -lt 10 ]; then
            echo "::warning::Expected at least 10 assets, found $ASSET_COUNT"
          fi
          
          # List assets
          echo ""
          echo "üìã Release assets:"
          echo "$RELEASE_INFO" | jq -r '.assets[] | "  - \(.name) (\(.size) bytes)"'
          
          # Check if marked as latest (only for non-prerelease)
          IS_PRERELEASE=$(echo "$RELEASE_INFO" | jq -r '.prerelease')
          if [ "$IS_PRERELEASE" = "false" ]; then
            # Verify this is the latest release
            LATEST_TAG=$(gh api repos/${{ github.repository }}/releases/latest | jq -r '.tag_name')
            if [ "$LATEST_TAG" = "${{ github.ref_name }}" ]; then
              echo "‚úÖ Release is marked as latest"
            else
              echo "::warning::Release is not marked as latest. Latest is: $LATEST_TAG"
            fi
          else
            echo "‚ÑπÔ∏è Pre-release - not expected to be latest"
          fi
          
          # Check checksums exist
          CHECKSUMS=$(echo "$RELEASE_INFO" | jq -r '.assets[] | select(.name == "checksums.txt") | .name')
          if [ -n "$CHECKSUMS" ]; then
            echo "‚úÖ Checksums file present"
          else
            echo "::error::checksums.txt not found in release assets!"
            exit 1
          fi
          
          echo ""
          echo "üéâ Release validation complete!"
