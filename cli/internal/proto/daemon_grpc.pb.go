// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.6.0
// - protoc             v4.25.1
// source: daemon.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	DaemonService_GetStatus_FullMethodName  = "/daemon.DaemonService/GetStatus"
	DaemonService_GetVersion_FullMethodName = "/daemon.DaemonService/GetVersion"
	DaemonService_Shutdown_FullMethodName   = "/daemon.DaemonService/Shutdown"
	DaemonService_Subscribe_FullMethodName  = "/daemon.DaemonService/Subscribe"
	DaemonService_Login_FullMethodName      = "/daemon.DaemonService/Login"
)

// DaemonServiceClient is the client API for DaemonService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// =============================================================================
// DAEMON SERVICE - Core daemon control and status
// =============================================================================
type DaemonServiceClient interface {
	// GetStatus returns the current status of the daemon and connection.
	GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error)
	// GetVersion returns daemon version info.
	GetVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error)
	// Shutdown gracefully stops the daemon.
	Shutdown(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Subscribe to real-time events (status changes, notifications).
	Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DaemonEvent], error)
	// Login initiates the device authentication flow and streams status updates.
	Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LoginUpdate], error)
}

type daemonServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDaemonServiceClient(cc grpc.ClientConnInterface) DaemonServiceClient {
	return &daemonServiceClient{cc}
}

func (c *daemonServiceClient) GetStatus(ctx context.Context, in *GetStatusRequest, opts ...grpc.CallOption) (*GetStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetStatusResponse)
	err := c.cc.Invoke(ctx, DaemonService_GetStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) GetVersion(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*VersionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(VersionResponse)
	err := c.cc.Invoke(ctx, DaemonService_GetVersion_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) Shutdown(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DaemonService_Shutdown_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *daemonServiceClient) Subscribe(ctx context.Context, in *SubscribeRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[DaemonEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DaemonService_ServiceDesc.Streams[0], DaemonService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, DaemonEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DaemonService_SubscribeClient = grpc.ServerStreamingClient[DaemonEvent]

func (c *daemonServiceClient) Login(ctx context.Context, in *LoginRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[LoginUpdate], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &DaemonService_ServiceDesc.Streams[1], DaemonService_Login_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[LoginRequest, LoginUpdate]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DaemonService_LoginClient = grpc.ServerStreamingClient[LoginUpdate]

// DaemonServiceServer is the server API for DaemonService service.
// All implementations must embed UnimplementedDaemonServiceServer
// for forward compatibility.
//
// =============================================================================
// DAEMON SERVICE - Core daemon control and status
// =============================================================================
type DaemonServiceServer interface {
	// GetStatus returns the current status of the daemon and connection.
	GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error)
	// GetVersion returns daemon version info.
	GetVersion(context.Context, *emptypb.Empty) (*VersionResponse, error)
	// Shutdown gracefully stops the daemon.
	Shutdown(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// Subscribe to real-time events (status changes, notifications).
	Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[DaemonEvent]) error
	// Login initiates the device authentication flow and streams status updates.
	Login(*LoginRequest, grpc.ServerStreamingServer[LoginUpdate]) error
	mustEmbedUnimplementedDaemonServiceServer()
}

// UnimplementedDaemonServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedDaemonServiceServer struct{}

func (UnimplementedDaemonServiceServer) GetStatus(context.Context, *GetStatusRequest) (*GetStatusResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedDaemonServiceServer) GetVersion(context.Context, *emptypb.Empty) (*VersionResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetVersion not implemented")
}
func (UnimplementedDaemonServiceServer) Shutdown(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method Shutdown not implemented")
}
func (UnimplementedDaemonServiceServer) Subscribe(*SubscribeRequest, grpc.ServerStreamingServer[DaemonEvent]) error {
	return status.Error(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedDaemonServiceServer) Login(*LoginRequest, grpc.ServerStreamingServer[LoginUpdate]) error {
	return status.Error(codes.Unimplemented, "method Login not implemented")
}
func (UnimplementedDaemonServiceServer) mustEmbedUnimplementedDaemonServiceServer() {}
func (UnimplementedDaemonServiceServer) testEmbeddedByValue()                       {}

// UnsafeDaemonServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DaemonServiceServer will
// result in compilation errors.
type UnsafeDaemonServiceServer interface {
	mustEmbedUnimplementedDaemonServiceServer()
}

func RegisterDaemonServiceServer(s grpc.ServiceRegistrar, srv DaemonServiceServer) {
	// If the following call panics, it indicates UnimplementedDaemonServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&DaemonService_ServiceDesc, srv)
}

func _DaemonService_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).GetStatus(ctx, req.(*GetStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_GetVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).GetVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_GetVersion_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).GetVersion(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DaemonServiceServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DaemonService_Shutdown_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DaemonServiceServer).Shutdown(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _DaemonService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServiceServer).Subscribe(m, &grpc.GenericServerStream[SubscribeRequest, DaemonEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DaemonService_SubscribeServer = grpc.ServerStreamingServer[DaemonEvent]

func _DaemonService_Login_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(LoginRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(DaemonServiceServer).Login(m, &grpc.GenericServerStream[LoginRequest, LoginUpdate]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type DaemonService_LoginServer = grpc.ServerStreamingServer[LoginUpdate]

// DaemonService_ServiceDesc is the grpc.ServiceDesc for DaemonService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DaemonService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "daemon.DaemonService",
	HandlerType: (*DaemonServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetStatus",
			Handler:    _DaemonService_GetStatus_Handler,
		},
		{
			MethodName: "GetVersion",
			Handler:    _DaemonService_GetVersion_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _DaemonService_Shutdown_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _DaemonService_Subscribe_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Login",
			Handler:       _DaemonService_Login_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "daemon.proto",
}

const (
	NetworkService_CreateNetwork_FullMethodName  = "/daemon.NetworkService/CreateNetwork"
	NetworkService_JoinNetwork_FullMethodName    = "/daemon.NetworkService/JoinNetwork"
	NetworkService_LeaveNetwork_FullMethodName   = "/daemon.NetworkService/LeaveNetwork"
	NetworkService_ListNetworks_FullMethodName   = "/daemon.NetworkService/ListNetworks"
	NetworkService_GetNetwork_FullMethodName     = "/daemon.NetworkService/GetNetwork"
	NetworkService_DeleteNetwork_FullMethodName  = "/daemon.NetworkService/DeleteNetwork"
	NetworkService_GenerateInvite_FullMethodName = "/daemon.NetworkService/GenerateInvite"
)

// NetworkServiceClient is the client API for NetworkService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// =============================================================================
// NETWORK SERVICE - Network creation, joining, and management
// =============================================================================
type NetworkServiceClient interface {
	// CreateNetwork creates a new virtual network.
	CreateNetwork(ctx context.Context, in *CreateNetworkRequest, opts ...grpc.CallOption) (*CreateNetworkResponse, error)
	// JoinNetwork joins an existing network via invite code.
	JoinNetwork(ctx context.Context, in *JoinNetworkRequest, opts ...grpc.CallOption) (*JoinNetworkResponse, error)
	// LeaveNetwork disconnects from a network.
	LeaveNetwork(ctx context.Context, in *LeaveNetworkRequest, opts ...grpc.CallOption) (*LeaveNetworkResponse, error)
	// ListNetworks returns all networks the user is part of.
	ListNetworks(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListNetworksResponse, error)
	// GetNetwork returns details of a specific network.
	GetNetwork(ctx context.Context, in *GetNetworkRequest, opts ...grpc.CallOption) (*Network, error)
	// DeleteNetwork deletes a network (owner only).
	DeleteNetwork(ctx context.Context, in *DeleteNetworkRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// GenerateInvite creates an invite code for a network.
	GenerateInvite(ctx context.Context, in *GenerateInviteRequest, opts ...grpc.CallOption) (*GenerateInviteResponse, error)
}

type networkServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkServiceClient(cc grpc.ClientConnInterface) NetworkServiceClient {
	return &networkServiceClient{cc}
}

func (c *networkServiceClient) CreateNetwork(ctx context.Context, in *CreateNetworkRequest, opts ...grpc.CallOption) (*CreateNetworkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateNetworkResponse)
	err := c.cc.Invoke(ctx, NetworkService_CreateNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) JoinNetwork(ctx context.Context, in *JoinNetworkRequest, opts ...grpc.CallOption) (*JoinNetworkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(JoinNetworkResponse)
	err := c.cc.Invoke(ctx, NetworkService_JoinNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) LeaveNetwork(ctx context.Context, in *LeaveNetworkRequest, opts ...grpc.CallOption) (*LeaveNetworkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(LeaveNetworkResponse)
	err := c.cc.Invoke(ctx, NetworkService_LeaveNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) ListNetworks(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListNetworksResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListNetworksResponse)
	err := c.cc.Invoke(ctx, NetworkService_ListNetworks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) GetNetwork(ctx context.Context, in *GetNetworkRequest, opts ...grpc.CallOption) (*Network, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Network)
	err := c.cc.Invoke(ctx, NetworkService_GetNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) DeleteNetwork(ctx context.Context, in *DeleteNetworkRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, NetworkService_DeleteNetwork_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkServiceClient) GenerateInvite(ctx context.Context, in *GenerateInviteRequest, opts ...grpc.CallOption) (*GenerateInviteResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GenerateInviteResponse)
	err := c.cc.Invoke(ctx, NetworkService_GenerateInvite_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkServiceServer is the server API for NetworkService service.
// All implementations must embed UnimplementedNetworkServiceServer
// for forward compatibility.
//
// =============================================================================
// NETWORK SERVICE - Network creation, joining, and management
// =============================================================================
type NetworkServiceServer interface {
	// CreateNetwork creates a new virtual network.
	CreateNetwork(context.Context, *CreateNetworkRequest) (*CreateNetworkResponse, error)
	// JoinNetwork joins an existing network via invite code.
	JoinNetwork(context.Context, *JoinNetworkRequest) (*JoinNetworkResponse, error)
	// LeaveNetwork disconnects from a network.
	LeaveNetwork(context.Context, *LeaveNetworkRequest) (*LeaveNetworkResponse, error)
	// ListNetworks returns all networks the user is part of.
	ListNetworks(context.Context, *emptypb.Empty) (*ListNetworksResponse, error)
	// GetNetwork returns details of a specific network.
	GetNetwork(context.Context, *GetNetworkRequest) (*Network, error)
	// DeleteNetwork deletes a network (owner only).
	DeleteNetwork(context.Context, *DeleteNetworkRequest) (*emptypb.Empty, error)
	// GenerateInvite creates an invite code for a network.
	GenerateInvite(context.Context, *GenerateInviteRequest) (*GenerateInviteResponse, error)
	mustEmbedUnimplementedNetworkServiceServer()
}

// UnimplementedNetworkServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedNetworkServiceServer struct{}

func (UnimplementedNetworkServiceServer) CreateNetwork(context.Context, *CreateNetworkRequest) (*CreateNetworkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method CreateNetwork not implemented")
}
func (UnimplementedNetworkServiceServer) JoinNetwork(context.Context, *JoinNetworkRequest) (*JoinNetworkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method JoinNetwork not implemented")
}
func (UnimplementedNetworkServiceServer) LeaveNetwork(context.Context, *LeaveNetworkRequest) (*LeaveNetworkResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method LeaveNetwork not implemented")
}
func (UnimplementedNetworkServiceServer) ListNetworks(context.Context, *emptypb.Empty) (*ListNetworksResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListNetworks not implemented")
}
func (UnimplementedNetworkServiceServer) GetNetwork(context.Context, *GetNetworkRequest) (*Network, error) {
	return nil, status.Error(codes.Unimplemented, "method GetNetwork not implemented")
}
func (UnimplementedNetworkServiceServer) DeleteNetwork(context.Context, *DeleteNetworkRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method DeleteNetwork not implemented")
}
func (UnimplementedNetworkServiceServer) GenerateInvite(context.Context, *GenerateInviteRequest) (*GenerateInviteResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GenerateInvite not implemented")
}
func (UnimplementedNetworkServiceServer) mustEmbedUnimplementedNetworkServiceServer() {}
func (UnimplementedNetworkServiceServer) testEmbeddedByValue()                        {}

// UnsafeNetworkServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkServiceServer will
// result in compilation errors.
type UnsafeNetworkServiceServer interface {
	mustEmbedUnimplementedNetworkServiceServer()
}

func RegisterNetworkServiceServer(s grpc.ServiceRegistrar, srv NetworkServiceServer) {
	// If the following call panics, it indicates UnimplementedNetworkServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&NetworkService_ServiceDesc, srv)
}

func _NetworkService_CreateNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).CreateNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_CreateNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).CreateNetwork(ctx, req.(*CreateNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_JoinNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JoinNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).JoinNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_JoinNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).JoinNetwork(ctx, req.(*JoinNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_LeaveNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LeaveNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).LeaveNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_LeaveNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).LeaveNetwork(ctx, req.(*LeaveNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_ListNetworks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).ListNetworks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_ListNetworks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).ListNetworks(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_GetNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).GetNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_GetNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).GetNetwork(ctx, req.(*GetNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_DeleteNetwork_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).DeleteNetwork(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_DeleteNetwork_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).DeleteNetwork(ctx, req.(*DeleteNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkService_GenerateInvite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateInviteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkServiceServer).GenerateInvite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkService_GenerateInvite_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkServiceServer).GenerateInvite(ctx, req.(*GenerateInviteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NetworkService_ServiceDesc is the grpc.ServiceDesc for NetworkService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "daemon.NetworkService",
	HandlerType: (*NetworkServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNetwork",
			Handler:    _NetworkService_CreateNetwork_Handler,
		},
		{
			MethodName: "JoinNetwork",
			Handler:    _NetworkService_JoinNetwork_Handler,
		},
		{
			MethodName: "LeaveNetwork",
			Handler:    _NetworkService_LeaveNetwork_Handler,
		},
		{
			MethodName: "ListNetworks",
			Handler:    _NetworkService_ListNetworks_Handler,
		},
		{
			MethodName: "GetNetwork",
			Handler:    _NetworkService_GetNetwork_Handler,
		},
		{
			MethodName: "DeleteNetwork",
			Handler:    _NetworkService_DeleteNetwork_Handler,
		},
		{
			MethodName: "GenerateInvite",
			Handler:    _NetworkService_GenerateInvite_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "daemon.proto",
}

const (
	PeerService_GetPeers_FullMethodName  = "/daemon.PeerService/GetPeers"
	PeerService_GetPeer_FullMethodName   = "/daemon.PeerService/GetPeer"
	PeerService_KickPeer_FullMethodName  = "/daemon.PeerService/KickPeer"
	PeerService_BanPeer_FullMethodName   = "/daemon.PeerService/BanPeer"
	PeerService_UnbanPeer_FullMethodName = "/daemon.PeerService/UnbanPeer"
)

// PeerServiceClient is the client API for PeerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// =============================================================================
// PEER SERVICE - Peer connection and management
// =============================================================================
type PeerServiceClient interface {
	// GetPeers returns all peers in the current network.
	GetPeers(ctx context.Context, in *GetPeersRequest, opts ...grpc.CallOption) (*GetPeersResponse, error)
	// GetPeer returns details of a specific peer.
	GetPeer(ctx context.Context, in *GetPeerRequest, opts ...grpc.CallOption) (*Peer, error)
	// KickPeer removes a peer from the network (host only).
	KickPeer(ctx context.Context, in *KickPeerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// BanPeer permanently bans a peer from the network (host only).
	BanPeer(ctx context.Context, in *BanPeerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// UnbanPeer removes a ban (host only).
	UnbanPeer(ctx context.Context, in *UnbanPeerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type peerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPeerServiceClient(cc grpc.ClientConnInterface) PeerServiceClient {
	return &peerServiceClient{cc}
}

func (c *peerServiceClient) GetPeers(ctx context.Context, in *GetPeersRequest, opts ...grpc.CallOption) (*GetPeersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetPeersResponse)
	err := c.cc.Invoke(ctx, PeerService_GetPeers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) GetPeer(ctx context.Context, in *GetPeerRequest, opts ...grpc.CallOption) (*Peer, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Peer)
	err := c.cc.Invoke(ctx, PeerService_GetPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) KickPeer(ctx context.Context, in *KickPeerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PeerService_KickPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) BanPeer(ctx context.Context, in *BanPeerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PeerService_BanPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *peerServiceClient) UnbanPeer(ctx context.Context, in *UnbanPeerRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, PeerService_UnbanPeer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PeerServiceServer is the server API for PeerService service.
// All implementations must embed UnimplementedPeerServiceServer
// for forward compatibility.
//
// =============================================================================
// PEER SERVICE - Peer connection and management
// =============================================================================
type PeerServiceServer interface {
	// GetPeers returns all peers in the current network.
	GetPeers(context.Context, *GetPeersRequest) (*GetPeersResponse, error)
	// GetPeer returns details of a specific peer.
	GetPeer(context.Context, *GetPeerRequest) (*Peer, error)
	// KickPeer removes a peer from the network (host only).
	KickPeer(context.Context, *KickPeerRequest) (*emptypb.Empty, error)
	// BanPeer permanently bans a peer from the network (host only).
	BanPeer(context.Context, *BanPeerRequest) (*emptypb.Empty, error)
	// UnbanPeer removes a ban (host only).
	UnbanPeer(context.Context, *UnbanPeerRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedPeerServiceServer()
}

// UnimplementedPeerServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPeerServiceServer struct{}

func (UnimplementedPeerServiceServer) GetPeers(context.Context, *GetPeersRequest) (*GetPeersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPeers not implemented")
}
func (UnimplementedPeerServiceServer) GetPeer(context.Context, *GetPeerRequest) (*Peer, error) {
	return nil, status.Error(codes.Unimplemented, "method GetPeer not implemented")
}
func (UnimplementedPeerServiceServer) KickPeer(context.Context, *KickPeerRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method KickPeer not implemented")
}
func (UnimplementedPeerServiceServer) BanPeer(context.Context, *BanPeerRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method BanPeer not implemented")
}
func (UnimplementedPeerServiceServer) UnbanPeer(context.Context, *UnbanPeerRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method UnbanPeer not implemented")
}
func (UnimplementedPeerServiceServer) mustEmbedUnimplementedPeerServiceServer() {}
func (UnimplementedPeerServiceServer) testEmbeddedByValue()                     {}

// UnsafePeerServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PeerServiceServer will
// result in compilation errors.
type UnsafePeerServiceServer interface {
	mustEmbedUnimplementedPeerServiceServer()
}

func RegisterPeerServiceServer(s grpc.ServiceRegistrar, srv PeerServiceServer) {
	// If the following call panics, it indicates UnimplementedPeerServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PeerService_ServiceDesc, srv)
}

func _PeerService_GetPeers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPeersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).GetPeers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_GetPeers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).GetPeers(ctx, req.(*GetPeersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_GetPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).GetPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_GetPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).GetPeer(ctx, req.(*GetPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_KickPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KickPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).KickPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_KickPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).KickPeer(ctx, req.(*KickPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_BanPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BanPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).BanPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_BanPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).BanPeer(ctx, req.(*BanPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PeerService_UnbanPeer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnbanPeerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PeerServiceServer).UnbanPeer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PeerService_UnbanPeer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PeerServiceServer).UnbanPeer(ctx, req.(*UnbanPeerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PeerService_ServiceDesc is the grpc.ServiceDesc for PeerService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PeerService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "daemon.PeerService",
	HandlerType: (*PeerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPeers",
			Handler:    _PeerService_GetPeers_Handler,
		},
		{
			MethodName: "GetPeer",
			Handler:    _PeerService_GetPeer_Handler,
		},
		{
			MethodName: "KickPeer",
			Handler:    _PeerService_KickPeer_Handler,
		},
		{
			MethodName: "BanPeer",
			Handler:    _PeerService_BanPeer_Handler,
		},
		{
			MethodName: "UnbanPeer",
			Handler:    _PeerService_UnbanPeer_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "daemon.proto",
}

const (
	ChatService_SendMessage_FullMethodName       = "/daemon.ChatService/SendMessage"
	ChatService_GetMessages_FullMethodName       = "/daemon.ChatService/GetMessages"
	ChatService_SubscribeMessages_FullMethodName = "/daemon.ChatService/SubscribeMessages"
)

// ChatServiceClient is the client API for ChatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// =============================================================================
// CHAT SERVICE - Text messaging between peers
// =============================================================================
type ChatServiceClient interface {
	// SendMessage sends a chat message to a peer or network.
	SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error)
	// GetMessages retrieves chat history.
	GetMessages(ctx context.Context, in *GetMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error)
	// SubscribeMessages streams incoming messages in real-time.
	SubscribeMessages(ctx context.Context, in *SubscribeMessagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatMessage], error)
}

type chatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewChatServiceClient(cc grpc.ClientConnInterface) ChatServiceClient {
	return &chatServiceClient{cc}
}

func (c *chatServiceClient) SendMessage(ctx context.Context, in *SendMessageRequest, opts ...grpc.CallOption) (*SendMessageResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendMessageResponse)
	err := c.cc.Invoke(ctx, ChatService_SendMessage_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) GetMessages(ctx context.Context, in *GetMessagesRequest, opts ...grpc.CallOption) (*GetMessagesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetMessagesResponse)
	err := c.cc.Invoke(ctx, ChatService_GetMessages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chatServiceClient) SubscribeMessages(ctx context.Context, in *SubscribeMessagesRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ChatMessage], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ChatService_ServiceDesc.Streams[0], ChatService_SubscribeMessages_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeMessagesRequest, ChatMessage]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_SubscribeMessagesClient = grpc.ServerStreamingClient[ChatMessage]

// ChatServiceServer is the server API for ChatService service.
// All implementations must embed UnimplementedChatServiceServer
// for forward compatibility.
//
// =============================================================================
// CHAT SERVICE - Text messaging between peers
// =============================================================================
type ChatServiceServer interface {
	// SendMessage sends a chat message to a peer or network.
	SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error)
	// GetMessages retrieves chat history.
	GetMessages(context.Context, *GetMessagesRequest) (*GetMessagesResponse, error)
	// SubscribeMessages streams incoming messages in real-time.
	SubscribeMessages(*SubscribeMessagesRequest, grpc.ServerStreamingServer[ChatMessage]) error
	mustEmbedUnimplementedChatServiceServer()
}

// UnimplementedChatServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedChatServiceServer struct{}

func (UnimplementedChatServiceServer) SendMessage(context.Context, *SendMessageRequest) (*SendMessageResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendMessage not implemented")
}
func (UnimplementedChatServiceServer) GetMessages(context.Context, *GetMessagesRequest) (*GetMessagesResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method GetMessages not implemented")
}
func (UnimplementedChatServiceServer) SubscribeMessages(*SubscribeMessagesRequest, grpc.ServerStreamingServer[ChatMessage]) error {
	return status.Error(codes.Unimplemented, "method SubscribeMessages not implemented")
}
func (UnimplementedChatServiceServer) mustEmbedUnimplementedChatServiceServer() {}
func (UnimplementedChatServiceServer) testEmbeddedByValue()                     {}

// UnsafeChatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ChatServiceServer will
// result in compilation errors.
type UnsafeChatServiceServer interface {
	mustEmbedUnimplementedChatServiceServer()
}

func RegisterChatServiceServer(s grpc.ServiceRegistrar, srv ChatServiceServer) {
	// If the following call panics, it indicates UnimplementedChatServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ChatService_ServiceDesc, srv)
}

func _ChatService_SendMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).SendMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_SendMessage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).SendMessage(ctx, req.(*SendMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_GetMessages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMessagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChatServiceServer).GetMessages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ChatService_GetMessages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChatServiceServer).GetMessages(ctx, req.(*GetMessagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChatService_SubscribeMessages_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(SubscribeMessagesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ChatServiceServer).SubscribeMessages(m, &grpc.GenericServerStream[SubscribeMessagesRequest, ChatMessage]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ChatService_SubscribeMessagesServer = grpc.ServerStreamingServer[ChatMessage]

// ChatService_ServiceDesc is the grpc.ServiceDesc for ChatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ChatService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "daemon.ChatService",
	HandlerType: (*ChatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendMessage",
			Handler:    _ChatService_SendMessage_Handler,
		},
		{
			MethodName: "GetMessages",
			Handler:    _ChatService_GetMessages_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeMessages",
			Handler:       _ChatService_SubscribeMessages_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "daemon.proto",
}

const (
	TransferService_SendFile_FullMethodName           = "/daemon.TransferService/SendFile"
	TransferService_AcceptTransfer_FullMethodName     = "/daemon.TransferService/AcceptTransfer"
	TransferService_RejectTransfer_FullMethodName     = "/daemon.TransferService/RejectTransfer"
	TransferService_CancelTransfer_FullMethodName     = "/daemon.TransferService/CancelTransfer"
	TransferService_ListTransfers_FullMethodName      = "/daemon.TransferService/ListTransfers"
	TransferService_SubscribeTransfers_FullMethodName = "/daemon.TransferService/SubscribeTransfers"
)

// TransferServiceClient is the client API for TransferService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// =============================================================================
// TRANSFER SERVICE - File transfer between peers
// =============================================================================
type TransferServiceClient interface {
	// SendFile initiates a file transfer to a peer.
	SendFile(ctx context.Context, in *SendFileRequest, opts ...grpc.CallOption) (*SendFileResponse, error)
	// AcceptTransfer accepts an incoming file transfer request.
	AcceptTransfer(ctx context.Context, in *AcceptTransferRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// RejectTransfer rejects an incoming file transfer request.
	RejectTransfer(ctx context.Context, in *RejectTransferRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CancelTransfer cancels an ongoing transfer.
	CancelTransfer(ctx context.Context, in *CancelTransferRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ListTransfers returns all active/recent transfers.
	ListTransfers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListTransfersResponse, error)
	// SubscribeTransfers streams transfer progress updates.
	SubscribeTransfers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TransferEvent], error)
}

type transferServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTransferServiceClient(cc grpc.ClientConnInterface) TransferServiceClient {
	return &transferServiceClient{cc}
}

func (c *transferServiceClient) SendFile(ctx context.Context, in *SendFileRequest, opts ...grpc.CallOption) (*SendFileResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SendFileResponse)
	err := c.cc.Invoke(ctx, TransferService_SendFile_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) AcceptTransfer(ctx context.Context, in *AcceptTransferRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TransferService_AcceptTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) RejectTransfer(ctx context.Context, in *RejectTransferRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TransferService_RejectTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) CancelTransfer(ctx context.Context, in *CancelTransferRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, TransferService_CancelTransfer_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) ListTransfers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListTransfersResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListTransfersResponse)
	err := c.cc.Invoke(ctx, TransferService_ListTransfers_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *transferServiceClient) SubscribeTransfers(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[TransferEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &TransferService_ServiceDesc.Streams[0], TransferService_SubscribeTransfers_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[emptypb.Empty, TransferEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TransferService_SubscribeTransfersClient = grpc.ServerStreamingClient[TransferEvent]

// TransferServiceServer is the server API for TransferService service.
// All implementations must embed UnimplementedTransferServiceServer
// for forward compatibility.
//
// =============================================================================
// TRANSFER SERVICE - File transfer between peers
// =============================================================================
type TransferServiceServer interface {
	// SendFile initiates a file transfer to a peer.
	SendFile(context.Context, *SendFileRequest) (*SendFileResponse, error)
	// AcceptTransfer accepts an incoming file transfer request.
	AcceptTransfer(context.Context, *AcceptTransferRequest) (*emptypb.Empty, error)
	// RejectTransfer rejects an incoming file transfer request.
	RejectTransfer(context.Context, *RejectTransferRequest) (*emptypb.Empty, error)
	// CancelTransfer cancels an ongoing transfer.
	CancelTransfer(context.Context, *CancelTransferRequest) (*emptypb.Empty, error)
	// ListTransfers returns all active/recent transfers.
	ListTransfers(context.Context, *emptypb.Empty) (*ListTransfersResponse, error)
	// SubscribeTransfers streams transfer progress updates.
	SubscribeTransfers(*emptypb.Empty, grpc.ServerStreamingServer[TransferEvent]) error
	mustEmbedUnimplementedTransferServiceServer()
}

// UnimplementedTransferServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedTransferServiceServer struct{}

func (UnimplementedTransferServiceServer) SendFile(context.Context, *SendFileRequest) (*SendFileResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method SendFile not implemented")
}
func (UnimplementedTransferServiceServer) AcceptTransfer(context.Context, *AcceptTransferRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method AcceptTransfer not implemented")
}
func (UnimplementedTransferServiceServer) RejectTransfer(context.Context, *RejectTransferRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method RejectTransfer not implemented")
}
func (UnimplementedTransferServiceServer) CancelTransfer(context.Context, *CancelTransferRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method CancelTransfer not implemented")
}
func (UnimplementedTransferServiceServer) ListTransfers(context.Context, *emptypb.Empty) (*ListTransfersResponse, error) {
	return nil, status.Error(codes.Unimplemented, "method ListTransfers not implemented")
}
func (UnimplementedTransferServiceServer) SubscribeTransfers(*emptypb.Empty, grpc.ServerStreamingServer[TransferEvent]) error {
	return status.Error(codes.Unimplemented, "method SubscribeTransfers not implemented")
}
func (UnimplementedTransferServiceServer) mustEmbedUnimplementedTransferServiceServer() {}
func (UnimplementedTransferServiceServer) testEmbeddedByValue()                         {}

// UnsafeTransferServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TransferServiceServer will
// result in compilation errors.
type UnsafeTransferServiceServer interface {
	mustEmbedUnimplementedTransferServiceServer()
}

func RegisterTransferServiceServer(s grpc.ServiceRegistrar, srv TransferServiceServer) {
	// If the following call panics, it indicates UnimplementedTransferServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&TransferService_ServiceDesc, srv)
}

func _TransferService_SendFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).SendFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_SendFile_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).SendFile(ctx, req.(*SendFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_AcceptTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AcceptTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).AcceptTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_AcceptTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).AcceptTransfer(ctx, req.(*AcceptTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_RejectTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RejectTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).RejectTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_RejectTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).RejectTransfer(ctx, req.(*RejectTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_CancelTransfer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelTransferRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).CancelTransfer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_CancelTransfer_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).CancelTransfer(ctx, req.(*CancelTransferRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_ListTransfers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TransferServiceServer).ListTransfers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TransferService_ListTransfers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TransferServiceServer).ListTransfers(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TransferService_SubscribeTransfers_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TransferServiceServer).SubscribeTransfers(m, &grpc.GenericServerStream[emptypb.Empty, TransferEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type TransferService_SubscribeTransfersServer = grpc.ServerStreamingServer[TransferEvent]

// TransferService_ServiceDesc is the grpc.ServiceDesc for TransferService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TransferService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "daemon.TransferService",
	HandlerType: (*TransferServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendFile",
			Handler:    _TransferService_SendFile_Handler,
		},
		{
			MethodName: "AcceptTransfer",
			Handler:    _TransferService_AcceptTransfer_Handler,
		},
		{
			MethodName: "RejectTransfer",
			Handler:    _TransferService_RejectTransfer_Handler,
		},
		{
			MethodName: "CancelTransfer",
			Handler:    _TransferService_CancelTransfer_Handler,
		},
		{
			MethodName: "ListTransfers",
			Handler:    _TransferService_ListTransfers_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeTransfers",
			Handler:       _TransferService_SubscribeTransfers_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "daemon.proto",
}

const (
	VoiceService_SendSignal_FullMethodName       = "/daemon.VoiceService/SendSignal"
	VoiceService_SubscribeSignals_FullMethodName = "/daemon.VoiceService/SubscribeSignals"
)

// VoiceServiceClient is the client API for VoiceService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// =============================================================================
// VOICE SERVICE - WebRTC signaling for voice chat
// =============================================================================
type VoiceServiceClient interface {
	// SendSignal routes a WebRTC signal to a peer.
	SendSignal(ctx context.Context, in *SendSignalRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SubscribeSignals streams incoming WebRTC signals.
	SubscribeSignals(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[VoiceSignal], error)
}

type voiceServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVoiceServiceClient(cc grpc.ClientConnInterface) VoiceServiceClient {
	return &voiceServiceClient{cc}
}

func (c *voiceServiceClient) SendSignal(ctx context.Context, in *SendSignalRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, VoiceService_SendSignal_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *voiceServiceClient) SubscribeSignals(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (grpc.ServerStreamingClient[VoiceSignal], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &VoiceService_ServiceDesc.Streams[0], VoiceService_SubscribeSignals_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[emptypb.Empty, VoiceSignal]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VoiceService_SubscribeSignalsClient = grpc.ServerStreamingClient[VoiceSignal]

// VoiceServiceServer is the server API for VoiceService service.
// All implementations must embed UnimplementedVoiceServiceServer
// for forward compatibility.
//
// =============================================================================
// VOICE SERVICE - WebRTC signaling for voice chat
// =============================================================================
type VoiceServiceServer interface {
	// SendSignal routes a WebRTC signal to a peer.
	SendSignal(context.Context, *SendSignalRequest) (*emptypb.Empty, error)
	// SubscribeSignals streams incoming WebRTC signals.
	SubscribeSignals(*emptypb.Empty, grpc.ServerStreamingServer[VoiceSignal]) error
	mustEmbedUnimplementedVoiceServiceServer()
}

// UnimplementedVoiceServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVoiceServiceServer struct{}

func (UnimplementedVoiceServiceServer) SendSignal(context.Context, *SendSignalRequest) (*emptypb.Empty, error) {
	return nil, status.Error(codes.Unimplemented, "method SendSignal not implemented")
}
func (UnimplementedVoiceServiceServer) SubscribeSignals(*emptypb.Empty, grpc.ServerStreamingServer[VoiceSignal]) error {
	return status.Error(codes.Unimplemented, "method SubscribeSignals not implemented")
}
func (UnimplementedVoiceServiceServer) mustEmbedUnimplementedVoiceServiceServer() {}
func (UnimplementedVoiceServiceServer) testEmbeddedByValue()                      {}

// UnsafeVoiceServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VoiceServiceServer will
// result in compilation errors.
type UnsafeVoiceServiceServer interface {
	mustEmbedUnimplementedVoiceServiceServer()
}

func RegisterVoiceServiceServer(s grpc.ServiceRegistrar, srv VoiceServiceServer) {
	// If the following call panics, it indicates UnimplementedVoiceServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VoiceService_ServiceDesc, srv)
}

func _VoiceService_SendSignal_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendSignalRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VoiceServiceServer).SendSignal(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VoiceService_SendSignal_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VoiceServiceServer).SendSignal(ctx, req.(*SendSignalRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VoiceService_SubscribeSignals_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(VoiceServiceServer).SubscribeSignals(m, &grpc.GenericServerStream[emptypb.Empty, VoiceSignal]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type VoiceService_SubscribeSignalsServer = grpc.ServerStreamingServer[VoiceSignal]

// VoiceService_ServiceDesc is the grpc.ServiceDesc for VoiceService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VoiceService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "daemon.VoiceService",
	HandlerType: (*VoiceServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "SendSignal",
			Handler:    _VoiceService_SendSignal_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "SubscribeSignals",
			Handler:       _VoiceService_SubscribeSignals_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "daemon.proto",
}

const (
	SettingsService_GetSettings_FullMethodName    = "/daemon.SettingsService/GetSettings"
	SettingsService_UpdateSettings_FullMethodName = "/daemon.SettingsService/UpdateSettings"
	SettingsService_ResetSettings_FullMethodName  = "/daemon.SettingsService/ResetSettings"
)

// SettingsServiceClient is the client API for SettingsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// =============================================================================
// SETTINGS SERVICE - Configuration management
// =============================================================================
type SettingsServiceClient interface {
	// GetSettings returns the current daemon settings.
	GetSettings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Settings, error)
	// UpdateSettings updates daemon settings.
	UpdateSettings(ctx context.Context, in *UpdateSettingsRequest, opts ...grpc.CallOption) (*Settings, error)
	// ResetSettings resets settings to defaults.
	ResetSettings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Settings, error)
}

type settingsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSettingsServiceClient(cc grpc.ClientConnInterface) SettingsServiceClient {
	return &settingsServiceClient{cc}
}

func (c *settingsServiceClient) GetSettings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Settings, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Settings)
	err := c.cc.Invoke(ctx, SettingsService_GetSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsServiceClient) UpdateSettings(ctx context.Context, in *UpdateSettingsRequest, opts ...grpc.CallOption) (*Settings, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Settings)
	err := c.cc.Invoke(ctx, SettingsService_UpdateSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *settingsServiceClient) ResetSettings(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Settings, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Settings)
	err := c.cc.Invoke(ctx, SettingsService_ResetSettings_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SettingsServiceServer is the server API for SettingsService service.
// All implementations must embed UnimplementedSettingsServiceServer
// for forward compatibility.
//
// =============================================================================
// SETTINGS SERVICE - Configuration management
// =============================================================================
type SettingsServiceServer interface {
	// GetSettings returns the current daemon settings.
	GetSettings(context.Context, *emptypb.Empty) (*Settings, error)
	// UpdateSettings updates daemon settings.
	UpdateSettings(context.Context, *UpdateSettingsRequest) (*Settings, error)
	// ResetSettings resets settings to defaults.
	ResetSettings(context.Context, *emptypb.Empty) (*Settings, error)
	mustEmbedUnimplementedSettingsServiceServer()
}

// UnimplementedSettingsServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSettingsServiceServer struct{}

func (UnimplementedSettingsServiceServer) GetSettings(context.Context, *emptypb.Empty) (*Settings, error) {
	return nil, status.Error(codes.Unimplemented, "method GetSettings not implemented")
}
func (UnimplementedSettingsServiceServer) UpdateSettings(context.Context, *UpdateSettingsRequest) (*Settings, error) {
	return nil, status.Error(codes.Unimplemented, "method UpdateSettings not implemented")
}
func (UnimplementedSettingsServiceServer) ResetSettings(context.Context, *emptypb.Empty) (*Settings, error) {
	return nil, status.Error(codes.Unimplemented, "method ResetSettings not implemented")
}
func (UnimplementedSettingsServiceServer) mustEmbedUnimplementedSettingsServiceServer() {}
func (UnimplementedSettingsServiceServer) testEmbeddedByValue()                         {}

// UnsafeSettingsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SettingsServiceServer will
// result in compilation errors.
type UnsafeSettingsServiceServer interface {
	mustEmbedUnimplementedSettingsServiceServer()
}

func RegisterSettingsServiceServer(s grpc.ServiceRegistrar, srv SettingsServiceServer) {
	// If the following call panics, it indicates UnimplementedSettingsServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SettingsService_ServiceDesc, srv)
}

func _SettingsService_GetSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServiceServer).GetSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettingsService_GetSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServiceServer).GetSettings(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsService_UpdateSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServiceServer).UpdateSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettingsService_UpdateSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServiceServer).UpdateSettings(ctx, req.(*UpdateSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SettingsService_ResetSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SettingsServiceServer).ResetSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SettingsService_ResetSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SettingsServiceServer).ResetSettings(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// SettingsService_ServiceDesc is the grpc.ServiceDesc for SettingsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SettingsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "daemon.SettingsService",
	HandlerType: (*SettingsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetSettings",
			Handler:    _SettingsService_GetSettings_Handler,
		},
		{
			MethodName: "UpdateSettings",
			Handler:    _SettingsService_UpdateSettings_Handler,
		},
		{
			MethodName: "ResetSettings",
			Handler:    _SettingsService_ResetSettings_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "daemon.proto",
}
