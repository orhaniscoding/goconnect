package wireguard

import (
	"context"
	"fmt"
	"net"
	"strings"

	"github.com/orhaniscoding/goconnect/server/internal/domain"
)

// ProfileGenerator generates WireGuard configuration files
type ProfileGenerator struct {
	serverEndpoint string // Public endpoint of the server (e.g., "vpn.example.com:51820")
	serverPubKey   string // Server's WireGuard public key
	dns            string // DNS servers for clients (comma-separated)
	mtu            int    // MTU for the interface
	keepalive      int    // Persistent keepalive in seconds
}

// NewProfileGenerator creates a new WireGuard profile generator
func NewProfileGenerator(serverEndpoint, serverPubKey, dns string, mtu, keepalive int) *ProfileGenerator {
	if mtu == 0 {
		mtu = 1420 // Default MTU for WireGuard
	}
	if keepalive == 0 {
		keepalive = 25 // Default keepalive (TECH_SPEC requirement)
	}
	if dns == "" {
		dns = "1.1.1.1, 1.0.0.1" // Cloudflare DNS as default
	}

	return &ProfileGenerator{
		serverEndpoint: serverEndpoint,
		serverPubKey:   serverPubKey,
		dns:            dns,
		mtu:            mtu,
		keepalive:      keepalive,
	}
}

// GenerateClientConfig generates a WireGuard config for a client device
func (g *ProfileGenerator) GenerateClientConfig(ctx context.Context, req *ProfileRequest) (string, error) {
	// Validate request
	if err := req.Validate(); err != nil {
		return "", err
	}

	// Build AllowedIPs from network CIDR
	allowedIPs := req.NetworkCIDR
	if req.IncludeHostScope {
		// If host scope is included, allow all traffic through VPN
		allowedIPs = "0.0.0.0/0, ::/0"
	}

	// Generate config
	var builder strings.Builder

	// Interface section
	builder.WriteString("[Interface]\n")
	builder.WriteString(fmt.Sprintf("# Generated by GoConnect for %s\n", req.DeviceName))
	builder.WriteString(fmt.Sprintf("# Network: %s\n", req.NetworkName))
	builder.WriteString(fmt.Sprintf("# User: %s\n", req.UserEmail))
	builder.WriteString(fmt.Sprintf("PrivateKey = %s\n", req.DevicePrivateKey))
	builder.WriteString(fmt.Sprintf("Address = %s/%d\n", req.DeviceIP, req.PrefixLen))
	builder.WriteString(fmt.Sprintf("DNS = %s\n", g.dns))
	builder.WriteString(fmt.Sprintf("MTU = %d\n\n", g.mtu))

	// Peer section (server)
	builder.WriteString("[Peer]\n")
	builder.WriteString("# GoConnect Server\n")
	builder.WriteString(fmt.Sprintf("PublicKey = %s\n", g.serverPubKey))
	builder.WriteString(fmt.Sprintf("Endpoint = %s\n", g.serverEndpoint))
	builder.WriteString(fmt.Sprintf("AllowedIPs = %s\n", allowedIPs))
	builder.WriteString(fmt.Sprintf("PersistentKeepalive = %d\n", g.keepalive))

	return builder.String(), nil
}

// ProfileRequest contains parameters for generating a WireGuard config
type ProfileRequest struct {
	// Network information
	NetworkID   string
	NetworkName string
	NetworkCIDR string // e.g., "10.0.1.0/24"

	// Device information
	DeviceID         string
	DeviceName       string
	DeviceIP         string // Allocated IP in the network
	DevicePrivateKey string // Client's WireGuard private key
	PrefixLen        int    // CIDR prefix length (e.g., 24)

	// User information
	UserID    string
	UserEmail string

	// Options
	IncludeHostScope bool // If true, route all traffic through VPN
}

// Validate validates the profile request
func (r *ProfileRequest) Validate() error {
	if r.NetworkID == "" {
		return domain.NewError(domain.ErrValidation, "network_id is required", nil)
	}
	if r.DeviceID == "" {
		return domain.NewError(domain.ErrValidation, "device_id is required", nil)
	}
	if r.DeviceIP == "" {
		return domain.NewError(domain.ErrValidation, "device_ip is required", nil)
	}
	if r.DevicePrivateKey == "" {
		return domain.NewError(domain.ErrValidation, "device_private_key is required", nil)
	}
	if r.NetworkCIDR == "" {
		return domain.NewError(domain.ErrValidation, "network_cidr is required", nil)
	}
	if r.PrefixLen == 0 {
		return domain.NewError(domain.ErrValidation, "prefix_len is required", nil)
	}

	// Validate CIDR format
	_, _, err := net.ParseCIDR(r.NetworkCIDR)
	if err != nil {
		return domain.NewError(domain.ErrCIDRInvalid, "Invalid network CIDR", map[string]string{
			"cidr": r.NetworkCIDR,
		})
	}

	// Validate device IP format
	ip := net.ParseIP(r.DeviceIP)
	if ip == nil {
		return domain.NewError(domain.ErrValidation, "Invalid device IP address", map[string]string{
			"device_ip": r.DeviceIP,
		})
	}

	// Validate WireGuard private key format (44 characters base64)
	if len(r.DevicePrivateKey) != 44 {
		return domain.NewError(domain.ErrValidation, "Invalid WireGuard private key format", map[string]string{
			"expected_length": "44",
			"actual_length":   fmt.Sprintf("%d", len(r.DevicePrivateKey)),
		})
	}

	return nil
}
